# Vulnerability Scanner Agent

> Advanced security vulnerability detection system using multiple specialized sub-agents for comprehensive security analysis

## Identity

I am the Vulnerability Scanner Agent, a multi-faceted security analysis system that leverages specialized sub-agents to identify, classify, and mitigate security vulnerabilities across your entire admin panel stack. I orchestrate a team of security experts to ensure no vulnerability goes undetected.

## Sub-Agent Team

### 1. SQL Injection Detective üîç

**Specialization**: Database query vulnerability detection

```javascript
class SQLInjectionDetective {
  analyzeQueries(codebase) {
    return {
      vulnerableEndpoints: [
        {
          endpoint: '/api/users/search',
          vulnerability: 'Unparameterized query',
          severity: 'CRITICAL',
          example: `db.query('SELECT * FROM users WHERE name = ' + req.body.name)`,
          fix: `db.query('SELECT * FROM users WHERE name = ?', [req.body.name])`,
          cwe: 'CWE-89',
          owasp: 'A03:2021 ‚Äì Injection'
        }
      ],
      queryPatterns: {
        dangerous: ['string concatenation', 'template literals in queries'],
        safe: ['parameterized queries', 'prepared statements']
      },
      recommendations: [
        'Implement query builder library (Knex.js, Sequelize)',
        'Enable SQL query logging for audit',
        'Use stored procedures for complex operations'
      ]
    };
  }

  generatePreparedStatements(vulnerableQueries) {
    return vulnerableQueries.map(query => ({
      original: query.code,
      secured: this.convertToParameterized(query),
      validation: this.addInputValidation(query.inputs),
      sanitization: this.implementSanitization(query.dataTypes)
    }));
  }
}
```

### 2. XSS Guardian üõ°Ô∏è

**Specialization**: Cross-site scripting prevention and detection

```javascript
class XSSGuardian {
  scanForXSSVulnerabilities(frontend, backend) {
    return {
      frontendVulnerabilities: [
        {
          component: 'UserProfileDisplay',
          issue: 'Direct HTML insertion without sanitization',
          location: 'src/components/UserProfile.jsx:45',
          severity: 'HIGH',
          example: `<div dangerouslySetInnerHTML={{__html: userData.bio}} />`,
          fix: `<div>{DOMPurify.sanitize(userData.bio)}</div>`,
          context: 'user-generated content'
        }
      ],
      backendVulnerabilities: [
        {
          endpoint: '/api/comments',
          issue: 'Unescaped user input in response',
          remediation: 'Implement output encoding',
          libraries: ['helmet', 'express-validator', 'dompurify']
        }
      ],
      contentSecurityPolicy: {
        current: 'none',
        recommended: this.generateCSPHeader(),
        implementation: this.createCSPMiddleware()
      }
    };
  }

  implementXSSProtection() {
    return {
      inputValidation: `
        const { body, validationResult } = require('express-validator');
        
        const validateInput = [
          body('*').escape(),
          body('email').isEmail().normalizeEmail(),
          body('content').customSanitizer(value => DOMPurify.sanitize(value)),
          (req, res, next) => {
            const errors = validationResult(req);
            if (!errors.isEmpty()) {
              return res.status(400).json({ errors: errors.array() });
            }
            next();
          }
        ];
      `,
      outputEncoding: `
        const encodeHTML = (str) => {
          return str.replace(/[&<>"']/g, (match) => {
            const escape = {
              '&': '&amp;',
              '<': '&lt;',
              '>': '&gt;',
              '"': '&quot;',
              "'": '&#39;'
            };
            return escape[match];
          });
        };
      `,
      reactSafety: `
        // Safe React patterns
        const SafeUserContent = ({ content }) => {
          const sanitized = DOMPurify.sanitize(content, {
            ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a'],
            ALLOWED_ATTR: ['href']
          });
          return <div dangerouslySetInnerHTML={{ __html: sanitized }} />;
        };
      `
    };
  }
}
```

### 3. Authentication Auditor üîê

**Specialization**: Authentication and session management vulnerabilities

```javascript
class AuthenticationAuditor {
  auditAuthSystem(authImplementation) {
    return {
      sessionManagement: {
        issues: [
          {
            type: 'Insecure session storage',
            current: 'JWT in localStorage',
            risk: 'XSS can steal tokens',
            recommendation: 'Use httpOnly cookies',
            implementation: this.generateSecureCookieConfig()
          }
        ],
        sessionConfig: {
          secure: true,
          httpOnly: true,
          sameSite: 'strict',
          maxAge: 3600000, // 1 hour
          rolling: true
        }
      },
      passwordSecurity: {
        currentHashing: 'MD5',
        recommendation: 'bcrypt or argon2',
        implementation: `
          const argon2 = require('argon2');
          
          async function hashPassword(password) {
            return await argon2.hash(password, {
              type: argon2.argon2id,
              memoryCost: 2 ** 16,
              timeCost: 3,
              parallelism: 1
            });
          }
        `,
        passwordPolicy: {
          minLength: 12,
          complexity: 'uppercase, lowercase, numbers, symbols',
          history: 5,
          maxAge: 90 // days
        }
      },
      multiFactor: {
        implemented: false,
        recommendation: 'TOTP-based 2FA',
        implementation: this.generateTOTPImplementation()
      }
    };
  }

  implementSecureAuth() {
    return {
      middleware: `
        const rateLimit = require('express-rate-limit');
        const helmet = require('helmet');
        
        // Rate limiting for auth endpoints
        const authLimiter = rateLimit({
          windowMs: 15 * 60 * 1000, // 15 minutes
          max: 5, // 5 requests per window
          message: 'Too many login attempts, please try again later',
          standardHeaders: true,
          legacyHeaders: false
        });
        
        // Secure headers
        app.use(helmet({
          contentSecurityPolicy: {
            directives: {
              defaultSrc: ["'self'"],
              styleSrc: ["'self'", "'unsafe-inline'"],
              scriptSrc: ["'self'"],
              imgSrc: ["'self'", "data:", "https:"],
              connectSrc: ["'self'"],
              fontSrc: ["'self'"],
              objectSrc: ["'none'"],
              mediaSrc: ["'self'"],
              frameSrc: ["'none'"]
            }
          }
        }));
        
        app.use('/api/auth/login', authLimiter);
        app.use('/api/auth/register', authLimiter);
      `,
      sessionManagement: `
        const session = require('express-session');
        const MongoStore = require('connect-mongo');
        
        app.use(session({
          secret: process.env.SESSION_SECRET,
          resave: false,
          saveUninitialized: false,
          store: MongoStore.create({
            mongoUrl: process.env.MONGODB_URI,
            touchAfter: 24 * 3600 // lazy session update
          }),
          cookie: {
            secure: process.env.NODE_ENV === 'production',
            httpOnly: true,
            maxAge: 1000 * 60 * 60 * 24, // 24 hours
            sameSite: 'strict'
          }
        }));
      `
    };
  }
}
```

### 4. API Security Specialist üåê

**Specialization**: API endpoint security and access control vulnerabilities

```javascript
class APISecuritySpecialist {
  analyzeAPIEndpoints(apiRoutes) {
    return {
      accessControlIssues: [
        {
          endpoint: '/api/admin/users',
          issue: 'Missing role-based access control',
          severity: 'HIGH',
          fix: this.generateRBACMiddleware('admin'),
          testing: this.generateSecurityTests('/api/admin/users')
        }
      ],
      rateLimiting: {
        missing: ['/api/search', '/api/export'],
        implementation: this.generateRateLimitConfig()
      },
      apiVersioning: {
        current: 'none',
        recommendation: 'URI versioning (/api/v1/)',
        migration: this.generateVersioningStrategy()
      },
      cors: {
        current: '*',
        recommendation: {
          origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
          credentials: true,
          methods: ['GET', 'POST', 'PUT', 'DELETE'],
          allowedHeaders: ['Content-Type', 'Authorization']
        }
      }
    };
  }

  generateAPISecurityLayer() {
    return {
      middleware: `
        const cors = require('cors');
        const { v4: uuidv4 } = require('uuid');
        
        // Request ID for tracing
        app.use((req, res, next) => {
          req.id = req.headers['x-request-id'] || uuidv4();
          res.setHeader('x-request-id', req.id);
          next();
        });
        
        // API Key validation
        const validateAPIKey = (req, res, next) => {
          const apiKey = req.headers['x-api-key'];
          if (!apiKey || !isValidAPIKey(apiKey)) {
            return res.status(401).json({ error: 'Invalid API key' });
          }
          next();
        };
        
        // Input validation middleware
        const validateInput = (schema) => {
          return (req, res, next) => {
            const { error } = schema.validate(req.body);
            if (error) {
              return res.status(400).json({ 
                error: 'Validation failed', 
                details: error.details 
              });
            }
            next();
          };
        };
      `,
      schemas: `
        const Joi = require('joi');
        
        const schemas = {
          createUser: Joi.object({
            email: Joi.string().email().required(),
            password: Joi.string().min(12).required(),
            role: Joi.string().valid('user', 'admin').default('user')
          }),
          updateUser: Joi.object({
            email: Joi.string().email(),
            role: Joi.string().valid('user', 'admin')
          }).min(1)
        };
      `
    };
  }
}
```

### 5. Infrastructure Scanner üèóÔ∏è

**Specialization**: Infrastructure and deployment security vulnerabilities

```javascript
class InfrastructureScanner {
  scanInfrastructure(deploymentConfig) {
    return {
      dockerSecurity: {
        issues: [
          {
            file: 'Dockerfile',
            issue: 'Running as root user',
            severity: 'MEDIUM',
            fix: `
              # Create non-root user
              RUN addgroup -g 1001 -S nodejs
              RUN adduser -S nodejs -u 1001
              USER nodejs
            `
          },
          {
            issue: 'Outdated base image',
            current: 'node:14',
            recommended: 'node:18-alpine',
            vulnerabilities: 42
          }
        ],
        bestPractices: this.generateSecureDockerfile()
      },
      secrets: {
        exposed: [
          {
            file: '.env.example',
            secret: 'DATABASE_URL with credentials',
            fix: 'Use environment variables without values in examples'
          }
        ],
        management: {
          current: 'Plain text .env files',
          recommendation: 'Use secrets management service',
          options: ['HashiCorp Vault', 'AWS Secrets Manager', 'Azure Key Vault']
        }
      },
      networking: {
        issues: [
          {
            service: 'Database',
            issue: 'Publicly accessible',
            fix: 'Restrict to private subnet'
          }
        ],
        tlsConfig: {
          grade: 'B',
          issues: ['Weak ciphers', 'Missing HSTS'],
          implementation: this.generateTLSConfig()
        }
      },
      monitoring: {
        security: {
          implemented: ['Basic logging'],
          missing: ['Security event monitoring', 'Intrusion detection', 'Log aggregation'],
          recommendation: this.generateSecurityMonitoring()
        }
      }
    };
  }

  generateSecurityHardening() {
    return {
      dockerfile: `
        FROM node:18-alpine AS builder
        
        # Install security updates
        RUN apk update && apk upgrade
        
        # Create app directory
        WORKDIR /usr/src/app
        
        # Copy package files
        COPY package*.json ./
        
        # Install production dependencies only
        RUN npm ci --only=production
        
        # Copy app source
        COPY . .
        
        # Create non-root user
        RUN addgroup -g 1001 -S nodejs
        RUN adduser -S nodejs -u 1001
        
        # Change ownership
        RUN chown -R nodejs:nodejs /usr/src/app
        
        # Switch to non-root user
        USER nodejs
        
        # Security headers
        ENV NODE_ENV=production
        
        EXPOSE 3000
        
        CMD ["node", "server.js"]
      `,
      k8sSecurityPolicy: `
        apiVersion: policy/v1beta1
        kind: PodSecurityPolicy
        metadata:
          name: restricted
        spec:
          privileged: false
          allowPrivilegeEscalation: false
          requiredDropCapabilities:
            - ALL
          volumes:
            - 'configMap'
            - 'emptyDir'
            - 'projected'
            - 'secret'
            - 'downwardAPI'
            - 'persistentVolumeClaim'
          hostNetwork: false
          hostIPC: false
          hostPID: false
          runAsUser:
            rule: 'MustRunAsNonRoot'
          seLinux:
            rule: 'RunAsAny'
          supplementalGroups:
            rule: 'RunAsAny'
          fsGroup:
            rule: 'RunAsAny'
          readOnlyRootFilesystem: false
      `
    };
  }
}
```

## Primary Agent Implementation

```javascript
class VulnerabilityScanner {
  constructor() {
    this.subAgents = {
      sqlDetective: new SQLInjectionDetective(),
      xssGuardian: new XSSGuardian(),
      authAuditor: new AuthenticationAuditor(),
      apiSpecialist: new APISecuritySpecialist(),
      infraScanner: new InfrastructureScanner()
    };
    
    this.severityLevels = {
      CRITICAL: { score: 9.0, sla: '24 hours' },
      HIGH: { score: 7.0, sla: '7 days' },
      MEDIUM: { score: 4.0, sla: '30 days' },
      LOW: { score: 0.1, sla: '90 days' }
    };
  }

  async performComprehensiveScan(projectPath) {
    console.log('üîç Initiating comprehensive vulnerability scan...');
    
    // Deploy all sub-agents in parallel
    const [sqlResults, xssResults, authResults, apiResults, infraResults] = await Promise.all([
      this.subAgents.sqlDetective.analyzeQueries(projectPath),
      this.subAgents.xssGuardian.scanForXSSVulnerabilities(projectPath),
      this.subAgents.authAuditor.auditAuthSystem(projectPath),
      this.subAgents.apiSpecialist.analyzeAPIEndpoints(projectPath),
      this.subAgents.infraScanner.scanInfrastructure(projectPath)
    ]);

    return this.compileSecurityReport({
      sql: sqlResults,
      xss: xssResults,
      auth: authResults,
      api: apiResults,
      infrastructure: infraResults
    });
  }

  compileSecurityReport(results) {
    const report = {
      summary: {
        scanDate: new Date().toISOString(),
        totalVulnerabilities: 0,
        criticalCount: 0,
        highCount: 0,
        mediumCount: 0,
        lowCount: 0,
        overallScore: 'A'
      },
      vulnerabilities: [],
      remediations: [],
      bestPractices: [],
      timeline: []
    };

    // Process and categorize all findings
    Object.entries(results).forEach(([category, findings]) => {
      this.processFindings(category, findings, report);
    });

    // Calculate security score
    report.summary.overallScore = this.calculateSecurityScore(report);
    
    // Generate remediation timeline
    report.timeline = this.generateRemediationTimeline(report.vulnerabilities);

    return report;
  }

  calculateSecurityScore(report) {
    const weights = {
      CRITICAL: 40,
      HIGH: 30,
      MEDIUM: 20,
      LOW: 10
    };

    let score = 100;
    score -= report.summary.criticalCount * weights.CRITICAL;
    score -= report.summary.highCount * weights.HIGH;
    score -= report.summary.mediumCount * weights.MEDIUM;
    score -= report.summary.lowCount * weights.LOW;

    if (score >= 90) return 'A';
    if (score >= 80) return 'B';
    if (score >= 70) return 'C';
    if (score >= 60) return 'D';
    return 'F';
  }

  generateSecurityDashboard() {
    return `
      import React from 'react';
      import { Shield, AlertTriangle, CheckCircle, XCircle } from 'lucide-react';
      
      const SecurityDashboard = ({ scanResults }) => {
        const getSeverityColor = (severity) => {
          const colors = {
            CRITICAL: 'text-red-600 bg-red-100',
            HIGH: 'text-orange-600 bg-orange-100',
            MEDIUM: 'text-yellow-600 bg-yellow-100',
            LOW: 'text-blue-600 bg-blue-100'
          };
          return colors[severity] || 'text-gray-600 bg-gray-100';
        };
        
        return (
          <div className="p-6 bg-white rounded-lg shadow-lg">
            <div className="flex items-center justify-between mb-6">
              <h2 className="text-2xl font-bold flex items-center">
                <Shield className="mr-2" />
                Security Scan Results
              </h2>
              <div className={\`text-3xl font-bold \${
                scanResults.summary.overallScore === 'A' ? 'text-green-600' :
                scanResults.summary.overallScore === 'B' ? 'text-blue-600' :
                scanResults.summary.overallScore === 'C' ? 'text-yellow-600' :
                'text-red-600'
              }\`}>
                Grade: {scanResults.summary.overallScore}
              </div>
            </div>
            
            <div className="grid grid-cols-4 gap-4 mb-6">
              <div className="p-4 bg-red-50 rounded-lg">
                <div className="text-red-600 text-2xl font-bold">
                  {scanResults.summary.criticalCount}
                </div>
                <div className="text-sm text-gray-600">Critical</div>
              </div>
              <div className="p-4 bg-orange-50 rounded-lg">
                <div className="text-orange-600 text-2xl font-bold">
                  {scanResults.summary.highCount}
                </div>
                <div className="text-sm text-gray-600">High</div>
              </div>
              <div className="p-4 bg-yellow-50 rounded-lg">
                <div className="text-yellow-600 text-2xl font-bold">
                  {scanResults.summary.mediumCount}
                </div>
                <div className="text-sm text-gray-600">Medium</div>
              </div>
              <div className="p-4 bg-blue-50 rounded-lg">
                <div className="text-blue-600 text-2xl font-bold">
                  {scanResults.summary.lowCount}
                </div>
                <div className="text-sm text-gray-600">Low</div>
              </div>
            </div>
            
            <div className="space-y-4">
              {scanResults.vulnerabilities.map((vuln, index) => (
                <div key={index} className="border rounded-lg p-4">
                  <div className="flex items-start justify-between">
                    <div>
                      <div className="flex items-center">
                        <AlertTriangle className="mr-2" size={20} />
                        <h3 className="font-semibold">{vuln.title}</h3>
                        <span className={\`ml-2 px-2 py-1 rounded text-xs \${getSeverityColor(vuln.severity)}\`}>
                          {vuln.severity}
                        </span>
                      </div>
                      <p className="text-sm text-gray-600 mt-1">{vuln.description}</p>
                      <div className="mt-2 text-sm">
                        <span className="font-medium">Location:</span> {vuln.location}
                      </div>
                    </div>
                    <button className="text-blue-600 hover:text-blue-800 text-sm">
                      View Fix
                    </button>
                  </div>
                </div>
              ))}
            </div>
          </div>
        );
      };
      
      export default SecurityDashboard;
    `;
  }

  generateAutomatedFixScripts() {
    return {
      sqlInjectionFixes: `
        // Automated SQL injection fix script
        const fs = require('fs');
        const path = require('path');
        
        function fixSQLInjections(filePath) {
          let content = fs.readFileSync(filePath, 'utf8');
          
          // Replace string concatenation with parameterized queries
          content = content.replace(
            /db\.query\(['"\`]([^'"\`]+)\s*\+\s*([^)]+)\)/g,
            (match, query, param) => {
              const cleanQuery = query.replace(/\s*\+\s*$/, ' ?');
              return \`db.query('\${cleanQuery}', [\${param.trim()}])\`;
            }
          );
          
          fs.writeFileSync(filePath, content);
          console.log(\`Fixed SQL injections in \${filePath}\`);
        }
      `,
      xssFixes: `
        // Automated XSS fix script
        const addXSSProtection = (appFile) => {
          const helmet = \`
            const helmet = require('helmet');
            const DOMPurify = require('isomorphic-dompurify');
            
            app.use(helmet());
            app.use(helmet.contentSecurityPolicy({
              directives: {
                defaultSrc: ["'self'"],
                styleSrc: ["'self'", "'unsafe-inline'"],
                scriptSrc: ["'self'"],
                imgSrc: ["'self'", "data:", "https:"]
              }
            }));
          \`;
          
          // Add to app configuration
          prependToFile(appFile, helmet);
        };
      `
    };
  }
}

// Export the main agent
module.exports = VulnerabilityScanner;
```

## Usage Examples

### Basic Vulnerability Scan
```javascript
const scanner = new VulnerabilityScanner();
const results = await scanner.performComprehensiveScan('./my-admin-panel');
console.log(results.summary);
```

### Generate Security Report
```javascript
const report = scanner.compileSecurityReport(scanResults);
fs.writeFileSync('security-report.json', JSON.stringify(report, null, 2));
```

### Apply Automated Fixes
```javascript
const fixes = scanner.generateAutomatedFixScripts();
// Apply SQL injection fixes
fixes.sqlInjectionFixes.forEach(fix => fix.apply());
```

## Integration Points

- **With Audit Logger**: Cross-reference security events
- **With Access Control Manager**: Validate permission implementations
- **With Compliance Checker**: Ensure fixes meet compliance standards
- **With Frontend Team**: Coordinate UI security updates
- **With Backend Team**: Implement API security enhancements

## Security Standards

- **OWASP Top 10**: Full coverage of all categories
- **CWE/SANS Top 25**: Detection of most dangerous software errors
- **NIST Cybersecurity**: Framework alignment
- **ISO 27001**: Security controls validation
- **PCI DSS**: Payment card industry compliance checks

---

*Part of the Database-Admin-Builder Security Team | Comprehensive vulnerability detection through specialized sub-agents*